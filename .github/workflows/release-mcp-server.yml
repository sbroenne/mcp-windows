name: Release MCP Server

# This workflow builds and releases the standalone Windows MCP Server
# Triggered by pushing tags matching 'mcp-v*'

on:
  push:
    tags:
      - 'mcp-v*'

jobs:
  build:
    runs-on: windows-latest

    strategy:
      matrix:
        rid: [win-x64, win-arm64]

    steps:
    - uses: actions/checkout@v4

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 10.0.x

    - name: Extract Version
      run: |
        $tagName = "${{ github.ref_name }}"
        $version = $tagName -replace '^mcp-v', ''
        Write-Output "Version: $version"
        "VERSION=$version" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
      shell: pwsh

    - name: Update Version in Project
      run: |
        $version = "${{ env.VERSION }}"
        $csprojPath = "src/Sbroenne.WindowsMcp/Sbroenne.WindowsMcp.csproj"
        $content = Get-Content $csprojPath -Raw
        $content = $content -replace '<Version>[\d\.]+</Version>', "<Version>$version</Version>"
        $content = $content -replace '<AssemblyVersion>[\d\.]+\.[\d\.]+</AssemblyVersion>', "<AssemblyVersion>$version.0</AssemblyVersion>"
        $content = $content -replace '<FileVersion>[\d\.]+\.[\d\.]+</FileVersion>', "<FileVersion>$version.0</FileVersion>"
        Set-Content $csprojPath $content
        Write-Output "Updated project to version $version"
      shell: pwsh

    - name: Restore Dependencies
      run: dotnet restore

    - name: Publish (Self-contained single-file)
      run: |
        $rid = "${{ matrix.rid }}"
        dotnet publish src/Sbroenne.WindowsMcp/Sbroenne.WindowsMcp.csproj `
          -c Release `
          -r $rid `
          -o "publish/$rid" `
          -p:SelfContained=true `
          -p:PublishSingleFile=true `
          -p:EnableCompressionInSingleFile=true `
          -p:IncludeNativeLibrariesForSelfExtract=true `
          -p:PublishReadyToRun=false
      shell: pwsh

    - name: Create Release Archive
      run: |
        $version = "${{ env.VERSION }}"
        $rid = "${{ matrix.rid }}"

        $publishDir = "publish/$rid"
        if (!(Test-Path $publishDir)) {
          Write-Error "Publish directory not found: $publishDir"
        }

        $zipName = "windows-mcp-server-$version-$rid.zip"
        Compress-Archive -Path "$publishDir/*" -DestinationPath $zipName

        Write-Output "Created release archive: $zipName"
        Get-ChildItem *.zip | Format-Table Name, Length
      shell: pwsh

    - name: Upload Build Artifact
      uses: actions/upload-artifact@v4
      with:
        name: release-${{ matrix.rid }}
        path: windows-mcp-server-*.zip
        retention-days: 1

  release:
    needs: build
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
    - name: Extract Version
      run: |
        tagName="${{ github.ref_name }}"
        version="${tagName#mcp-v}"
        echo "Version: $version"
        echo "VERSION=$version" >> $GITHUB_ENV

    - name: Download All Artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts
        pattern: release-*
        merge-multiple: true

    - name: List Artifacts
      run: |
        echo "Downloaded artifacts:"
        ls -la artifacts/

    - name: Assemble Release Notes
      run: |
        tagName="${{ github.ref_name }}"
        version="${{ env.VERSION }}"

        cat > release_notes.md << 'EOF'
## Windows MCP Server

**Let AI agents control Windows applications.** Click buttons, type text, toggle settings — all by name, not coordinates.

Uses the **Windows UI Automation API** to find UI elements reliably, regardless of DPI, theme, resolution, or window position.

### Why UI Automation First?

Most automation tools take a screenshot, send it to a vision model, and guess where to click. That breaks when the window moves, the theme changes, or the DPI is different.

Windows MCP Server queries the UI directly — it finds buttons by name, not pixels.

| | Screenshot-Based | Windows MCP Server |
|---|---|---|
| **Finds elements by** | Parsing pixels | **Name, type, or ID** |
| **DPI/theme changes** | Breaks | **Works** |
| **Speed** | ~2-5 seconds | **~50 milliseconds** |
| **Tokens per action** | ~1500 (image) | **~50 (text)** |

### Downloads (no .NET runtime required)
EOF
        cat >> release_notes.md << EOF

| File | Architecture |
|------|--------------|
| windows-mcp-server-${version}-win-x64.zip | x64 (most PCs) |
| windows-mcp-server-${version}-win-arm64.zip | ARM64 (Surface Pro X, ARM dev kits) |

Each zip contains a single, self-contained \`Sbroenne.WindowsMcp.exe\`.

### Tools

| Tool | Description |
|------|-------------|
| \`ui_automation\` | **Primary tool** — find elements by name, click, type, toggle, ensure_state |
| \`screenshot_control\` | Annotated screenshots with element overlays for discovery |
| \`mouse_control\` | Fallback mouse input for games/custom UIs |
| \`keyboard_control\` | Type text, press keys, hotkey sequences |
| \`window_management\` | Find, activate, move, resize windows |

### Usage

1. Download the zip for your architecture
2. Extract (contains \`Sbroenne.WindowsMcp.exe\`)
3. Add to your MCP client config:

\`\`\`json
{
  "servers": {
    "windows": {
      "command": "path/to/Sbroenne.WindowsMcp.exe"
    }
  }
}
\`\`\`

See [README](https://github.com/sbroenne/mcp-windows/blob/main/README.md) for full documentation.
EOF

    - name: Create GitHub Release
      run: |
        tagName="${{ github.ref_name }}"
        gh release create "$tagName" \
          artifacts/*.zip \
          --repo ${{ github.repository }} \
          --title "Windows MCP Server $tagName" \
          --notes-file release_notes.md
        echo "Released Windows MCP Server ${{ env.VERSION }}"
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
